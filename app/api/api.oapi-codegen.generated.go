// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// AdminAddUserPathJSONBody defines parameters for AdminAddUserPath.
type AdminAddUserPathJSONBody struct {
	FamilyId       int    `json:"familyId"`
	LockerPasscode string `json:"lockerPasscode" validate:"omitempty,min=6,max=6"`
	Mobile         string `json:"mobile" validate:"omitempty,min=4,max=20"`
	Name           string `json:"name" validate:"min=1,max=40"`
	Password       string `json:"password" validate:"omitempty,min=6,max=50"`
	Role           string `json:"role" validate:"omitempty"`
}

// AdminAddUserPathParams defines parameters for AdminAddUserPath.
type AdminAddUserPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AdminDeleteUserPathParams defines parameters for AdminDeleteUserPath.
type AdminDeleteUserPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AdminListUsersPathParams defines parameters for AdminListUsersPath.
type AdminListUsersPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AdminSaveUserPathJSONBody defines parameters for AdminSaveUserPath.
type AdminSaveUserPathJSONBody struct {
	FamilyId       *int    `json:"familyId,omitempty"`
	LockerPasscode *string `json:"lockerPasscode,omitempty" validate:"omitempty,min=6,max=6"`
	Mobile         string  `json:"mobile" validate:"omitempty,min=4,max=20"`
	Name           string  `json:"name" validate:"min=1,max=40"`
	Password       *string `json:"password,omitempty" validate:"omitempty,min=6,max=50"`
	Role           string  `json:"role" validate:"omitempty"`
}

// AdminSaveUserPathParams defines parameters for AdminSaveUserPath.
type AdminSaveUserPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AuthAccessTokenLoginPathJSONBody defines parameters for AuthAccessTokenLoginPath.
type AuthAccessTokenLoginPathJSONBody struct {
	DeviceToken string `json:"deviceToken"`
}

// AuthAccessTokenLoginPathParams defines parameters for AuthAccessTokenLoginPath.
type AuthAccessTokenLoginPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AuthMobileLoginPathJSONBody defines parameters for AuthMobileLoginPath.
type AuthMobileLoginPathJSONBody struct {
	DeviceToken string `json:"deviceToken"`
	Mobile      string `json:"mobile" validate:"min=4,max=20"`
	Password    string `json:"password" validate:"min=6,max=50"`
}

// AuthMobileLoginPathParams defines parameters for AuthMobileLoginPath.
type AuthMobileLoginPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileDisplayOriginalPathParams defines parameters for FolderFileDisplayOriginalPath.
type FolderFileDisplayOriginalPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileDisplayThumbnailPathParams defines parameters for FolderFileDisplayThumbnailPath.
type FolderFileDisplayThumbnailPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileDisplayPathParams defines parameters for FolderFileDisplayPath.
type FolderFileDisplayPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileGetChunkUploadIdPathParams defines parameters for FolderFileGetChunkUploadIdPath.
type FolderFileGetChunkUploadIdPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileChunkUploadPathParams defines parameters for FolderFileChunkUploadPath.
type FolderFileChunkUploadPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`

	// HasMore Are there more chunks, use string, "1" and "0" for true/false
	HasMore string `json:"HasMore"`

	// Filename File original name
	Filename string `json:"Filename"`

	// ChunkIndex The index of current chunk
	ChunkIndex string `json:"ChunkIndex"`

	// UploadId Id generated by server side (by calling the appropriate api endpoint)
	UploadId string `json:"UploadId"`
}

// FolderFileDeleteFolderFilesPathJSONBody defines parameters for FolderFileDeleteFolderFilesPath.
type FolderFileDeleteFolderFilesPathJSONBody struct {
	FolderFileIds []int64 `json:"folderFileIds"`
}

// FolderFileDeleteFolderFilesPathParams defines parameters for FolderFileDeleteFolderFilesPath.
type FolderFileDeleteFolderFilesPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileGetFolderFilesAfterMicroTimestampTakenOnParams defines parameters for FolderFileGetFolderFilesAfterMicroTimestampTakenOn.
type FolderFileGetFolderFilesAfterMicroTimestampTakenOnParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileGetFolderFilesBeforeMicroTimestampTakenOnParams defines parameters for FolderFileGetFolderFilesBeforeMicroTimestampTakenOn.
type FolderFileGetFolderFilesBeforeMicroTimestampTakenOnParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileUpdateMultipleFolderFilesPathJSONBody defines parameters for FolderFileUpdateMultipleFolderFilesPath.
type FolderFileUpdateMultipleFolderFilesPathJSONBody struct {
	FolderFileIds       []int64 `json:"folderFileIds"`
	NewFolderId         *int64  `json:"newFolderId,omitempty"`
	NewTakenOnTimestamp *int64  `json:"newTakenOnTimestamp,omitempty"`
}

// FolderFileUpdateMultipleFolderFilesPathParams defines parameters for FolderFileUpdateMultipleFolderFilesPath.
type FolderFileUpdateMultipleFolderFilesPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileUpdateSingleFolderFilePathJSONBody defines parameters for FolderFileUpdateSingleFolderFilePath.
type FolderFileUpdateSingleFolderFilePathJSONBody struct {
	FolderFileId int64   `json:"folderFileId"`
	IsPrivate    *bool   `json:"isPrivate,omitempty"`
	Remark       *string `json:"remark,omitempty"`
}

// FolderFileUpdateSingleFolderFilePathParams defines parameters for FolderFileUpdateSingleFolderFilePath.
type FolderFileUpdateSingleFolderFilePathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileDeleteFolderPathParams defines parameters for FolderFileDeleteFolderPath.
type FolderFileDeleteFolderPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileSaveFolderPathJSONBody defines parameters for FolderFileSaveFolderPath.
type FolderFileSaveFolderPathJSONBody struct {
	Cover      string                 `json:"cover"`
	InviteeIds []int64                `json:"inviteeIds"`
	IsDefault  bool                   `json:"isDefault"`
	IsPrivate  bool                   `json:"isPrivate"`
	Metadata   map[string]interface{} `json:"metadata"`
	OwnerId    int64                  `json:"ownerId"`
	ParentId   int64                  `json:"parentId"`
	Title      string                 `json:"title"`
	Type       string                 `json:"type"`
}

// FolderFileSaveFolderPathParams defines parameters for FolderFileSaveFolderPath.
type FolderFileSaveFolderPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// LockerNoteDeletePathParams defines parameters for LockerNoteDeletePath.
type LockerNoteDeletePathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// LockerNoteListPathParams defines parameters for LockerNoteListPath.
type LockerNoteListPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// LockerNoteSavePathJSONBody defines parameters for LockerNoteSavePath.
type LockerNoteSavePathJSONBody struct {
	Content    string   `json:"content"`
	InviteeIds *[]int64 `json:"inviteeIds,omitempty"`
	Title      string   `json:"title"`
}

// LockerNoteSavePathParams defines parameters for LockerNoteSavePath.
type LockerNoteSavePathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UserUpdateProfilePathJSONBody defines parameters for UserUpdateProfilePath.
type UserUpdateProfilePathJSONBody struct {
	AvatarUrl      *string `json:"avatarUrl" validate:"omitempty,min=1"`
	LockerPasscode *string `json:"lockerPasscode" validate:"omitempty,min=6,max=6"`
	Mobile         *string `json:"mobile" validate:"omitempty,min=4,max=20"`
	Name           *string `json:"name" validate:"omitempty,min=1,max=40"`
	Password       *string `json:"password" validate:"omitempty,min=6,max=50"`
}

// UserUpdateProfilePathParams defines parameters for UserUpdateProfilePath.
type UserUpdateProfilePathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UtilBase64ChunkUploadPathJSONBody defines parameters for UtilBase64ChunkUploadPath.
type UtilBase64ChunkUploadPathJSONBody struct {
	Base64EncodedContent string `json:"base64EncodedContent"`
	ChunkedFileName      string `json:"chunkedFileName"`
	FileName             string `json:"fileName"`
	HasMore              bool   `json:"hasMore"`
}

// UtilBase64ChunkUploadPathParams defines parameters for UtilBase64ChunkUploadPath.
type UtilBase64ChunkUploadPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UtilCheckForMobileUpdatePathParams defines parameters for UtilCheckForMobileUpdatePath.
type UtilCheckForMobileUpdatePathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UtilConfigPathParams defines parameters for UtilConfigPath.
type UtilConfigPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UtilPingPathParams defines parameters for UtilPingPath.
type UtilPingPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UtilDisplayUserAvatarPathParams defines parameters for UtilDisplayUserAvatarPath.
type UtilDisplayUserAvatarPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AdminAddUserPathJSONRequestBody defines body for AdminAddUserPath for application/json ContentType.
type AdminAddUserPathJSONRequestBody AdminAddUserPathJSONBody

// AdminSaveUserPathJSONRequestBody defines body for AdminSaveUserPath for application/json ContentType.
type AdminSaveUserPathJSONRequestBody AdminSaveUserPathJSONBody

// AuthAccessTokenLoginPathJSONRequestBody defines body for AuthAccessTokenLoginPath for application/json ContentType.
type AuthAccessTokenLoginPathJSONRequestBody AuthAccessTokenLoginPathJSONBody

// AuthMobileLoginPathJSONRequestBody defines body for AuthMobileLoginPath for application/json ContentType.
type AuthMobileLoginPathJSONRequestBody AuthMobileLoginPathJSONBody

// FolderFileDeleteFolderFilesPathJSONRequestBody defines body for FolderFileDeleteFolderFilesPath for application/json ContentType.
type FolderFileDeleteFolderFilesPathJSONRequestBody FolderFileDeleteFolderFilesPathJSONBody

// FolderFileUpdateMultipleFolderFilesPathJSONRequestBody defines body for FolderFileUpdateMultipleFolderFilesPath for application/json ContentType.
type FolderFileUpdateMultipleFolderFilesPathJSONRequestBody FolderFileUpdateMultipleFolderFilesPathJSONBody

// FolderFileUpdateSingleFolderFilePathJSONRequestBody defines body for FolderFileUpdateSingleFolderFilePath for application/json ContentType.
type FolderFileUpdateSingleFolderFilePathJSONRequestBody FolderFileUpdateSingleFolderFilePathJSONBody

// FolderFileSaveFolderPathJSONRequestBody defines body for FolderFileSaveFolderPath for application/json ContentType.
type FolderFileSaveFolderPathJSONRequestBody FolderFileSaveFolderPathJSONBody

// LockerNoteSavePathJSONRequestBody defines body for LockerNoteSavePath for application/json ContentType.
type LockerNoteSavePathJSONRequestBody LockerNoteSavePathJSONBody

// UserUpdateProfilePathJSONRequestBody defines body for UserUpdateProfilePath for application/json ContentType.
type UserUpdateProfilePathJSONRequestBody UserUpdateProfilePathJSONBody

// UtilBase64ChunkUploadPathJSONRequestBody defines body for UtilBase64ChunkUploadPath for application/json ContentType.
type UtilBase64ChunkUploadPathJSONRequestBody UtilBase64ChunkUploadPathJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Admin add user
	// (POST /api/v2/admin/add-user)
	AdminAddUserPath(c *gin.Context, params AdminAddUserPathParams)
	// Admin delete user
	// (POST /api/v2/admin/delete-user/{uuid})
	AdminDeleteUserPath(c *gin.Context, uuid string, params AdminDeleteUserPathParams)
	// Admin list users
	// (POST /api/v2/admin/list-all-users/{afterId})
	AdminListUsersPath(c *gin.Context, afterId int64, params AdminListUsersPathParams)
	// Admin save user
	// (POST /api/v2/admin/update-user/{userId})
	AdminSaveUserPath(c *gin.Context, userId int64, params AdminSaveUserPathParams)
	// Refresh access token if it's about to expire
	// (POST /api/v2/auth/access-token-login)
	AuthAccessTokenLoginPath(c *gin.Context, params AuthAccessTokenLoginPathParams)
	// Mobile login using mobile number and password
	// (POST /api/v2/auth/mobile-login)
	AuthMobileLoginPath(c *gin.Context, params AuthMobileLoginPathParams)
	// Display folder file
	// (GET /api/v2/folder-file-display/folder-file-original/{folderFileId})
	FolderFileDisplayOriginalPath(c *gin.Context, folderFileId int64, params FolderFileDisplayOriginalPathParams)
	// Display folder file
	// (GET /api/v2/folder-file-display/folder-file-thumbnail/{folderFileId})
	FolderFileDisplayThumbnailPath(c *gin.Context, folderFileId int64, params FolderFileDisplayThumbnailPathParams)
	// Display folder file
	// (GET /api/v2/folder-file-display/folder-file/{folderFileId})
	FolderFileDisplayPath(c *gin.Context, folderFileId int64, params FolderFileDisplayPathParams)
	// Folder file chunk upload
	// (POST /api/v2/folder-files/chunk-upload-folder-file-init-upload-id)
	FolderFileGetChunkUploadIdPath(c *gin.Context, params FolderFileGetChunkUploadIdPathParams)
	// Folder file chunk upload
	// (POST /api/v2/folder-files/chunk-upload-folder-file/{folderId})
	FolderFileChunkUploadPath(c *gin.Context, folderId int64, params FolderFileChunkUploadPathParams)
	// Delete folder files based on ids
	// (POST /api/v2/folder-files/delete-files/{folderId})
	FolderFileDeleteFolderFilesPath(c *gin.Context, folderId int64, params FolderFileDeleteFolderFilesPathParams)
	// Get folder files after date time
	// (POST /api/v2/folder-files/get-folder-files-after-micro-timestamp/{folderId}/{pivotDate}/{microTimestamp})
	FolderFileGetFolderFilesAfterMicroTimestampTakenOn(c *gin.Context, folderId int64, pivotDate string, microTimestamp int64, params FolderFileGetFolderFilesAfterMicroTimestampTakenOnParams)
	// Get folder files before date time
	// (POST /api/v2/folder-files/get-folder-files-before-micro-timestamp/{folderId}/{pivotDate}/{microTimestamp})
	FolderFileGetFolderFilesBeforeMicroTimestampTakenOn(c *gin.Context, folderId int64, pivotDate string, microTimestamp int64, params FolderFileGetFolderFilesBeforeMicroTimestampTakenOnParams)
	// Update multiple folder files
	// (POST /api/v2/folder-files/update-multiple-folder-files)
	FolderFileUpdateMultipleFolderFilesPath(c *gin.Context, params FolderFileUpdateMultipleFolderFilesPathParams)
	// Update one single folder file
	// (POST /api/v2/folder-files/update-single-folder-file)
	FolderFileUpdateSingleFolderFilePath(c *gin.Context, params FolderFileUpdateSingleFolderFilePathParams)
	// Delete user's folder
	// (POST /api/v2/folder/delete-folder/{folderId})
	FolderFileDeleteFolderPath(c *gin.Context, folderId int64, params FolderFileDeleteFolderPathParams)
	// Save folder
	// (POST /api/v2/folder/save-folder/{folderId})
	FolderFileSaveFolderPath(c *gin.Context, folderId int64, params FolderFileSaveFolderPathParams)
	// Delete user's locker note
	// (POST /api/v2/locker-notes/delete-note/{noteId})
	LockerNoteDeletePath(c *gin.Context, noteId int64, params LockerNoteDeletePathParams)
	// List user's locker notes
	// (POST /api/v2/locker-notes/list-notes)
	LockerNoteListPath(c *gin.Context, params LockerNoteListPathParams)
	// Save user's locker note
	// (POST /api/v2/locker-notes/save-note/{noteId})
	LockerNoteSavePath(c *gin.Context, noteId int64, params LockerNoteSavePathParams)
	// Update user's profile
	// (POST /api/v2/user/update-profile)
	UserUpdateProfilePath(c *gin.Context, params UserUpdateProfilePathParams)
	// Base64 encoded chunk upload
	// (POST /api/v2/util/base64-chunked-upload-file)
	UtilBase64ChunkUploadPath(c *gin.Context, params UtilBase64ChunkUploadPathParams)
	// Check for update
	// (GET /api/v2/util/check-for-mobile-update/{clientOs}/{clientVersion})
	UtilCheckForMobileUpdatePath(c *gin.Context, clientOs string, clientVersion string, params UtilCheckForMobileUpdatePathParams)
	// Get system config
	// (POST /api/v2/util/config/{configKey})
	UtilConfigPath(c *gin.Context, configKey string, params UtilConfigPathParams)
	// Ping for health
	// (GET /api/v2/util/ping)
	UtilPingPath(c *gin.Context, params UtilPingPathParams)
	// Display user avatar
	// (GET /api/v2/util/user-avatar/{userId})
	UtilDisplayUserAvatarPath(c *gin.Context, userId int64, params UtilDisplayUserAvatarPathParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// AdminAddUserPath operation middleware
func (siw *ServerInterfaceWrapper) AdminAddUserPath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminAddUserPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AdminAddUserPath(c, params)
}

// AdminDeleteUserPath operation middleware
func (siw *ServerInterfaceWrapper) AdminDeleteUserPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid string

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", c.Param("uuid"), &uuid, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter uuid: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminDeleteUserPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AdminDeleteUserPath(c, uuid, params)
}

// AdminListUsersPath operation middleware
func (siw *ServerInterfaceWrapper) AdminListUsersPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "afterId" -------------
	var afterId int64

	err = runtime.BindStyledParameterWithOptions("simple", "afterId", c.Param("afterId"), &afterId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter afterId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminListUsersPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AdminListUsersPath(c, afterId, params)
}

// AdminSaveUserPath operation middleware
func (siw *ServerInterfaceWrapper) AdminSaveUserPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId int64

	err = runtime.BindStyledParameterWithOptions("simple", "userId", c.Param("userId"), &userId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter userId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminSaveUserPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AdminSaveUserPath(c, userId, params)
}

// AuthAccessTokenLoginPath operation middleware
func (siw *ServerInterfaceWrapper) AuthAccessTokenLoginPath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthAccessTokenLoginPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AuthAccessTokenLoginPath(c, params)
}

// AuthMobileLoginPath operation middleware
func (siw *ServerInterfaceWrapper) AuthMobileLoginPath(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthMobileLoginPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AuthMobileLoginPath(c, params)
}

// FolderFileDisplayOriginalPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileDisplayOriginalPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderFileId" -------------
	var folderFileId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderFileId", c.Param("folderFileId"), &folderFileId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderFileId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileDisplayOriginalPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileDisplayOriginalPath(c, folderFileId, params)
}

// FolderFileDisplayThumbnailPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileDisplayThumbnailPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderFileId" -------------
	var folderFileId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderFileId", c.Param("folderFileId"), &folderFileId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderFileId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileDisplayThumbnailPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileDisplayThumbnailPath(c, folderFileId, params)
}

// FolderFileDisplayPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileDisplayPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderFileId" -------------
	var folderFileId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderFileId", c.Param("folderFileId"), &folderFileId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderFileId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileDisplayPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileDisplayPath(c, folderFileId, params)
}

// FolderFileGetChunkUploadIdPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileGetChunkUploadIdPath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileGetChunkUploadIdPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileGetChunkUploadIdPath(c, params)
}

// FolderFileChunkUploadPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileChunkUploadPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderId" -------------
	var folderId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderId", c.Param("folderId"), &folderId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileChunkUploadPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	// ------------- Required header parameter "HasMore" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("HasMore")]; found {
		var HasMore string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for HasMore, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "HasMore", valueList[0], &HasMore, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter HasMore: %w", err), http.StatusBadRequest)
			return
		}

		params.HasMore = HasMore

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter HasMore is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "Filename" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Filename")]; found {
		var Filename string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Filename, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Filename", valueList[0], &Filename, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Filename: %w", err), http.StatusBadRequest)
			return
		}

		params.Filename = Filename

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Filename is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "ChunkIndex" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("ChunkIndex")]; found {
		var ChunkIndex string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for ChunkIndex, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "ChunkIndex", valueList[0], &ChunkIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ChunkIndex: %w", err), http.StatusBadRequest)
			return
		}

		params.ChunkIndex = ChunkIndex

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter ChunkIndex is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "UploadId" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("UploadId")]; found {
		var UploadId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for UploadId, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "UploadId", valueList[0], &UploadId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter UploadId: %w", err), http.StatusBadRequest)
			return
		}

		params.UploadId = UploadId

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter UploadId is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileChunkUploadPath(c, folderId, params)
}

// FolderFileDeleteFolderFilesPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileDeleteFolderFilesPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderId" -------------
	var folderId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderId", c.Param("folderId"), &folderId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileDeleteFolderFilesPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileDeleteFolderFilesPath(c, folderId, params)
}

// FolderFileGetFolderFilesAfterMicroTimestampTakenOn operation middleware
func (siw *ServerInterfaceWrapper) FolderFileGetFolderFilesAfterMicroTimestampTakenOn(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderId" -------------
	var folderId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderId", c.Param("folderId"), &folderId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "pivotDate" -------------
	var pivotDate string

	err = runtime.BindStyledParameterWithOptions("simple", "pivotDate", c.Param("pivotDate"), &pivotDate, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pivotDate: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "microTimestamp" -------------
	var microTimestamp int64

	err = runtime.BindStyledParameterWithOptions("simple", "microTimestamp", c.Param("microTimestamp"), &microTimestamp, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter microTimestamp: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileGetFolderFilesAfterMicroTimestampTakenOnParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileGetFolderFilesAfterMicroTimestampTakenOn(c, folderId, pivotDate, microTimestamp, params)
}

// FolderFileGetFolderFilesBeforeMicroTimestampTakenOn operation middleware
func (siw *ServerInterfaceWrapper) FolderFileGetFolderFilesBeforeMicroTimestampTakenOn(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderId" -------------
	var folderId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderId", c.Param("folderId"), &folderId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "pivotDate" -------------
	var pivotDate string

	err = runtime.BindStyledParameterWithOptions("simple", "pivotDate", c.Param("pivotDate"), &pivotDate, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pivotDate: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "microTimestamp" -------------
	var microTimestamp int64

	err = runtime.BindStyledParameterWithOptions("simple", "microTimestamp", c.Param("microTimestamp"), &microTimestamp, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter microTimestamp: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileGetFolderFilesBeforeMicroTimestampTakenOnParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileGetFolderFilesBeforeMicroTimestampTakenOn(c, folderId, pivotDate, microTimestamp, params)
}

// FolderFileUpdateMultipleFolderFilesPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileUpdateMultipleFolderFilesPath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileUpdateMultipleFolderFilesPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileUpdateMultipleFolderFilesPath(c, params)
}

// FolderFileUpdateSingleFolderFilePath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileUpdateSingleFolderFilePath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileUpdateSingleFolderFilePathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileUpdateSingleFolderFilePath(c, params)
}

// FolderFileDeleteFolderPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileDeleteFolderPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderId" -------------
	var folderId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderId", c.Param("folderId"), &folderId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileDeleteFolderPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileDeleteFolderPath(c, folderId, params)
}

// FolderFileSaveFolderPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileSaveFolderPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderId" -------------
	var folderId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderId", c.Param("folderId"), &folderId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileSaveFolderPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileSaveFolderPath(c, folderId, params)
}

// LockerNoteDeletePath operation middleware
func (siw *ServerInterfaceWrapper) LockerNoteDeletePath(c *gin.Context) {

	var err error

	// ------------- Path parameter "noteId" -------------
	var noteId int64

	err = runtime.BindStyledParameterWithOptions("simple", "noteId", c.Param("noteId"), &noteId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter noteId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params LockerNoteDeletePathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.LockerNoteDeletePath(c, noteId, params)
}

// LockerNoteListPath operation middleware
func (siw *ServerInterfaceWrapper) LockerNoteListPath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params LockerNoteListPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.LockerNoteListPath(c, params)
}

// LockerNoteSavePath operation middleware
func (siw *ServerInterfaceWrapper) LockerNoteSavePath(c *gin.Context) {

	var err error

	// ------------- Path parameter "noteId" -------------
	var noteId int64

	err = runtime.BindStyledParameterWithOptions("simple", "noteId", c.Param("noteId"), &noteId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter noteId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params LockerNoteSavePathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.LockerNoteSavePath(c, noteId, params)
}

// UserUpdateProfilePath operation middleware
func (siw *ServerInterfaceWrapper) UserUpdateProfilePath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UserUpdateProfilePathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UserUpdateProfilePath(c, params)
}

// UtilBase64ChunkUploadPath operation middleware
func (siw *ServerInterfaceWrapper) UtilBase64ChunkUploadPath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UtilBase64ChunkUploadPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UtilBase64ChunkUploadPath(c, params)
}

// UtilCheckForMobileUpdatePath operation middleware
func (siw *ServerInterfaceWrapper) UtilCheckForMobileUpdatePath(c *gin.Context) {

	var err error

	// ------------- Path parameter "clientOs" -------------
	var clientOs string

	err = runtime.BindStyledParameterWithOptions("simple", "clientOs", c.Param("clientOs"), &clientOs, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter clientOs: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "clientVersion" -------------
	var clientVersion string

	err = runtime.BindStyledParameterWithOptions("simple", "clientVersion", c.Param("clientVersion"), &clientVersion, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter clientVersion: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UtilCheckForMobileUpdatePathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UtilCheckForMobileUpdatePath(c, clientOs, clientVersion, params)
}

// UtilConfigPath operation middleware
func (siw *ServerInterfaceWrapper) UtilConfigPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "configKey" -------------
	var configKey string

	err = runtime.BindStyledParameterWithOptions("simple", "configKey", c.Param("configKey"), &configKey, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter configKey: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UtilConfigPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UtilConfigPath(c, configKey, params)
}

// UtilPingPath operation middleware
func (siw *ServerInterfaceWrapper) UtilPingPath(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UtilPingPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UtilPingPath(c, params)
}

// UtilDisplayUserAvatarPath operation middleware
func (siw *ServerInterfaceWrapper) UtilDisplayUserAvatarPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId int64

	err = runtime.BindStyledParameterWithOptions("simple", "userId", c.Param("userId"), &userId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter userId: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UtilDisplayUserAvatarPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UtilDisplayUserAvatarPath(c, userId, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/api/v2/admin/add-user", wrapper.AdminAddUserPath)
	router.POST(options.BaseURL+"/api/v2/admin/delete-user/:uuid", wrapper.AdminDeleteUserPath)
	router.POST(options.BaseURL+"/api/v2/admin/list-all-users/:afterId", wrapper.AdminListUsersPath)
	router.POST(options.BaseURL+"/api/v2/admin/update-user/:userId", wrapper.AdminSaveUserPath)
	router.POST(options.BaseURL+"/api/v2/auth/access-token-login", wrapper.AuthAccessTokenLoginPath)
	router.POST(options.BaseURL+"/api/v2/auth/mobile-login", wrapper.AuthMobileLoginPath)
	router.GET(options.BaseURL+"/api/v2/folder-file-display/folder-file-original/:folderFileId", wrapper.FolderFileDisplayOriginalPath)
	router.GET(options.BaseURL+"/api/v2/folder-file-display/folder-file-thumbnail/:folderFileId", wrapper.FolderFileDisplayThumbnailPath)
	router.GET(options.BaseURL+"/api/v2/folder-file-display/folder-file/:folderFileId", wrapper.FolderFileDisplayPath)
	router.POST(options.BaseURL+"/api/v2/folder-files/chunk-upload-folder-file-init-upload-id", wrapper.FolderFileGetChunkUploadIdPath)
	router.POST(options.BaseURL+"/api/v2/folder-files/chunk-upload-folder-file/:folderId", wrapper.FolderFileChunkUploadPath)
	router.POST(options.BaseURL+"/api/v2/folder-files/delete-files/:folderId", wrapper.FolderFileDeleteFolderFilesPath)
	router.POST(options.BaseURL+"/api/v2/folder-files/get-folder-files-after-micro-timestamp/:folderId/:pivotDate/:microTimestamp", wrapper.FolderFileGetFolderFilesAfterMicroTimestampTakenOn)
	router.POST(options.BaseURL+"/api/v2/folder-files/get-folder-files-before-micro-timestamp/:folderId/:pivotDate/:microTimestamp", wrapper.FolderFileGetFolderFilesBeforeMicroTimestampTakenOn)
	router.POST(options.BaseURL+"/api/v2/folder-files/update-multiple-folder-files", wrapper.FolderFileUpdateMultipleFolderFilesPath)
	router.POST(options.BaseURL+"/api/v2/folder-files/update-single-folder-file", wrapper.FolderFileUpdateSingleFolderFilePath)
	router.POST(options.BaseURL+"/api/v2/folder/delete-folder/:folderId", wrapper.FolderFileDeleteFolderPath)
	router.POST(options.BaseURL+"/api/v2/folder/save-folder/:folderId", wrapper.FolderFileSaveFolderPath)
	router.POST(options.BaseURL+"/api/v2/locker-notes/delete-note/:noteId", wrapper.LockerNoteDeletePath)
	router.POST(options.BaseURL+"/api/v2/locker-notes/list-notes", wrapper.LockerNoteListPath)
	router.POST(options.BaseURL+"/api/v2/locker-notes/save-note/:noteId", wrapper.LockerNoteSavePath)
	router.POST(options.BaseURL+"/api/v2/user/update-profile", wrapper.UserUpdateProfilePath)
	router.POST(options.BaseURL+"/api/v2/util/base64-chunked-upload-file", wrapper.UtilBase64ChunkUploadPath)
	router.GET(options.BaseURL+"/api/v2/util/check-for-mobile-update/:clientOs/:clientVersion", wrapper.UtilCheckForMobileUpdatePath)
	router.POST(options.BaseURL+"/api/v2/util/config/:configKey", wrapper.UtilConfigPath)
	router.GET(options.BaseURL+"/api/v2/util/ping", wrapper.UtilPingPath)
	router.GET(options.BaseURL+"/api/v2/util/user-avatar/:userId", wrapper.UtilDisplayUserAvatarPath)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"CwAA//9qsXdolF8AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
