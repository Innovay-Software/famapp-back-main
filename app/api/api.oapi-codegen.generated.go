// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// AdminAddUserPathJSONBody defines parameters for AdminAddUserPath.
type AdminAddUserPathJSONBody struct {
	FamilyId       int    `json:"familyId"`
	LockerPasscode string `json:"lockerPasscode" validate:"omitempty,min=6,max=6"`
	Mobile         string `json:"mobile" validate:"omitempty,min=4,max=20"`
	Name           string `json:"name" validate:"min=1,max=40"`
	Password       string `json:"password" validate:"omitempty,min=6,max=50"`
	Role           string `json:"role" validate:"omitempty"`
}

// AdminAddUserPathParams defines parameters for AdminAddUserPath.
type AdminAddUserPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AdminDeleteUserPathParams defines parameters for AdminDeleteUserPath.
type AdminDeleteUserPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AdminListUsersPathParams defines parameters for AdminListUsersPath.
type AdminListUsersPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AdminSaveUserPathJSONBody defines parameters for AdminSaveUserPath.
type AdminSaveUserPathJSONBody struct {
	FamilyId       *int    `json:"familyId,omitempty"`
	LockerPasscode *string `json:"lockerPasscode,omitempty" validate:"omitempty,min=6,max=6"`
	Mobile         string  `json:"mobile" validate:"omitempty,min=4,max=20"`
	Name           string  `json:"name" validate:"min=1,max=40"`
	Password       *string `json:"password,omitempty" validate:"omitempty,min=6,max=50"`
	Role           string  `json:"role" validate:"omitempty"`
}

// AdminSaveUserPathParams defines parameters for AdminSaveUserPath.
type AdminSaveUserPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AuthAccessTokenLoginPathJSONBody defines parameters for AuthAccessTokenLoginPath.
type AuthAccessTokenLoginPathJSONBody struct {
	DeviceToken string `json:"deviceToken"`
}

// AuthAccessTokenLoginPathParams defines parameters for AuthAccessTokenLoginPath.
type AuthAccessTokenLoginPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AuthMobileLoginPathJSONBody defines parameters for AuthMobileLoginPath.
type AuthMobileLoginPathJSONBody struct {
	DeviceToken string `json:"deviceToken"`
	Mobile      string `json:"mobile" validate:"min=4,max=20"`
	Password    string `json:"password" validate:"min=6,max=50"`
}

// AuthMobileLoginPathParams defines parameters for AuthMobileLoginPath.
type AuthMobileLoginPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileDisplayOriginalPathParams defines parameters for FolderFileDisplayOriginalPath.
type FolderFileDisplayOriginalPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileDisplayThumbnailPathParams defines parameters for FolderFileDisplayThumbnailPath.
type FolderFileDisplayThumbnailPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileDisplayPathParams defines parameters for FolderFileDisplayPath.
type FolderFileDisplayPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileGetChunkUploadIdPathParams defines parameters for FolderFileGetChunkUploadIdPath.
type FolderFileGetChunkUploadIdPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileChunkUploadPathParams defines parameters for FolderFileChunkUploadPath.
type FolderFileChunkUploadPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`

	// HasMore Are there more chunks, use string, "1" and "0" for true/false
	HasMore string `json:"HasMore"`

	// Filename File original name
	Filename string `json:"Filename"`

	// ChunkIndex The index of current chunk
	ChunkIndex string `json:"ChunkIndex"`

	// UploadId Id generated by server side (by calling the appropriate api endpoint)
	UploadId string `json:"UploadId"`
}

// FolderFileDeleteFolderFilesPathJSONBody defines parameters for FolderFileDeleteFolderFilesPath.
type FolderFileDeleteFolderFilesPathJSONBody struct {
	FolderFileIds []int64 `json:"folderFileIds"`
}

// FolderFileDeleteFolderFilesPathParams defines parameters for FolderFileDeleteFolderFilesPath.
type FolderFileDeleteFolderFilesPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileGetFolderFilesAfterMicroTimestampShotAtParams defines parameters for FolderFileGetFolderFilesAfterMicroTimestampShotAt.
type FolderFileGetFolderFilesAfterMicroTimestampShotAtParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileGetFolderFilesBeforeMicroTimestampShotAtParams defines parameters for FolderFileGetFolderFilesBeforeMicroTimestampShotAt.
type FolderFileGetFolderFilesBeforeMicroTimestampShotAtParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileUpdateMultipleFolderFilesPathJSONBody defines parameters for FolderFileUpdateMultipleFolderFilesPath.
type FolderFileUpdateMultipleFolderFilesPathJSONBody struct {
	FolderFileIds      []int64 `json:"folderFileIds"`
	NewFolderId        *int64  `json:"newFolderId,omitempty"`
	NewShotAtTimestamp *int64  `json:"newShotAtTimestamp,omitempty"`
}

// FolderFileUpdateMultipleFolderFilesPathParams defines parameters for FolderFileUpdateMultipleFolderFilesPath.
type FolderFileUpdateMultipleFolderFilesPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileUpdateSingleFolderFilePathJSONBody defines parameters for FolderFileUpdateSingleFolderFilePath.
type FolderFileUpdateSingleFolderFilePathJSONBody struct {
	FolderFileId int64   `json:"folderFileId"`
	IsPrivate    *bool   `json:"isPrivate,omitempty"`
	Remark       *string `json:"remark,omitempty"`
}

// FolderFileUpdateSingleFolderFilePathParams defines parameters for FolderFileUpdateSingleFolderFilePath.
type FolderFileUpdateSingleFolderFilePathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileDeleteFolderPathParams defines parameters for FolderFileDeleteFolderPath.
type FolderFileDeleteFolderPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FolderFileSaveFolderPathJSONBody defines parameters for FolderFileSaveFolderPath.
type FolderFileSaveFolderPathJSONBody struct {
	Cover      string                 `json:"cover"`
	InviteeIds []int64                `json:"inviteeIds"`
	IsDefault  bool                   `json:"isDefault"`
	IsPrivate  bool                   `json:"isPrivate"`
	Metadata   map[string]interface{} `json:"metadata"`
	OwnerId    int64                  `json:"ownerId"`
	ParentId   int64                  `json:"parentId"`
	Title      string                 `json:"title"`
	Type       string                 `json:"type"`
}

// FolderFileSaveFolderPathParams defines parameters for FolderFileSaveFolderPath.
type FolderFileSaveFolderPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// LockerNoteDeletePathParams defines parameters for LockerNoteDeletePath.
type LockerNoteDeletePathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// LockerNoteListPathParams defines parameters for LockerNoteListPath.
type LockerNoteListPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// LockerNoteSavePathJSONBody defines parameters for LockerNoteSavePath.
type LockerNoteSavePathJSONBody struct {
	Content    string   `json:"content"`
	InviteeIds *[]int64 `json:"inviteeIds,omitempty"`
	Title      string   `json:"title"`
}

// LockerNoteSavePathParams defines parameters for LockerNoteSavePath.
type LockerNoteSavePathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UserUpdateProfilePathJSONBody defines parameters for UserUpdateProfilePath.
type UserUpdateProfilePathJSONBody struct {
	AvatarUrl      *string `json:"avatarUrl,omitempty" validate:"omitempty"`
	LockerPasscode *string `json:"lockerPasscode,omitempty" validate:"omitempty,min=6,max=6"`
	Mobile         *string `json:"mobile,omitempty" validate:"omitempty,min=4,max=20"`
	Name           *string `json:"name,omitempty" validate:"omitempty,min=1,max=40"`
	Password       *string `json:"password,omitempty" validate:"omitempty,min=6,max=50"`
}

// UserUpdateProfilePathParams defines parameters for UserUpdateProfilePath.
type UserUpdateProfilePathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UtilBase64ChunkUploadPathJSONBody defines parameters for UtilBase64ChunkUploadPath.
type UtilBase64ChunkUploadPathJSONBody struct {
	Base64EncodedContent string `json:"base64EncodedContent"`
	ChunkedFileName      string `json:"chunkedFileName"`
	FileName             string `json:"fileName"`
	HasMore              bool   `json:"hasMore"`
}

// UtilBase64ChunkUploadPathParams defines parameters for UtilBase64ChunkUploadPath.
type UtilBase64ChunkUploadPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UtilCheckForUpdatePathParams defines parameters for UtilCheckForUpdatePath.
type UtilCheckForUpdatePathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UtilConfigPathParams defines parameters for UtilConfigPath.
type UtilConfigPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UtilPingPathParams defines parameters for UtilPingPath.
type UtilPingPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UtilDisplayUserAvatarPathParams defines parameters for UtilDisplayUserAvatarPath.
type UtilDisplayUserAvatarPathParams struct {
	// AcceptLanguage Accepted language from client side
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AdminAddUserPathJSONRequestBody defines body for AdminAddUserPath for application/json ContentType.
type AdminAddUserPathJSONRequestBody AdminAddUserPathJSONBody

// AdminSaveUserPathJSONRequestBody defines body for AdminSaveUserPath for application/json ContentType.
type AdminSaveUserPathJSONRequestBody AdminSaveUserPathJSONBody

// AuthAccessTokenLoginPathJSONRequestBody defines body for AuthAccessTokenLoginPath for application/json ContentType.
type AuthAccessTokenLoginPathJSONRequestBody AuthAccessTokenLoginPathJSONBody

// AuthMobileLoginPathJSONRequestBody defines body for AuthMobileLoginPath for application/json ContentType.
type AuthMobileLoginPathJSONRequestBody AuthMobileLoginPathJSONBody

// FolderFileDeleteFolderFilesPathJSONRequestBody defines body for FolderFileDeleteFolderFilesPath for application/json ContentType.
type FolderFileDeleteFolderFilesPathJSONRequestBody FolderFileDeleteFolderFilesPathJSONBody

// FolderFileUpdateMultipleFolderFilesPathJSONRequestBody defines body for FolderFileUpdateMultipleFolderFilesPath for application/json ContentType.
type FolderFileUpdateMultipleFolderFilesPathJSONRequestBody FolderFileUpdateMultipleFolderFilesPathJSONBody

// FolderFileUpdateSingleFolderFilePathJSONRequestBody defines body for FolderFileUpdateSingleFolderFilePath for application/json ContentType.
type FolderFileUpdateSingleFolderFilePathJSONRequestBody FolderFileUpdateSingleFolderFilePathJSONBody

// FolderFileSaveFolderPathJSONRequestBody defines body for FolderFileSaveFolderPath for application/json ContentType.
type FolderFileSaveFolderPathJSONRequestBody FolderFileSaveFolderPathJSONBody

// LockerNoteSavePathJSONRequestBody defines body for LockerNoteSavePath for application/json ContentType.
type LockerNoteSavePathJSONRequestBody LockerNoteSavePathJSONBody

// UserUpdateProfilePathJSONRequestBody defines body for UserUpdateProfilePath for application/json ContentType.
type UserUpdateProfilePathJSONRequestBody UserUpdateProfilePathJSONBody

// UtilBase64ChunkUploadPathJSONRequestBody defines body for UtilBase64ChunkUploadPath for application/json ContentType.
type UtilBase64ChunkUploadPathJSONRequestBody UtilBase64ChunkUploadPathJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Admin add user
	// (POST /api/v2/admin/add-user)
	AdminAddUserPath(c *gin.Context, params AdminAddUserPathParams)
	// Admin delete user
	// (POST /api/v2/admin/delete-user/{uuid})
	AdminDeleteUserPath(c *gin.Context, uuid string, params AdminDeleteUserPathParams)
	// Admin list users
	// (POST /api/v2/admin/list-all-users/{afterId})
	AdminListUsersPath(c *gin.Context, afterId int64, params AdminListUsersPathParams)
	// Admin save user
	// (POST /api/v2/admin/update-user/{userId})
	AdminSaveUserPath(c *gin.Context, userId int64, params AdminSaveUserPathParams)
	// Refresh access token if it's about to expire
	// (POST /api/v2/auth/access-token-login)
	AuthAccessTokenLoginPath(c *gin.Context, params AuthAccessTokenLoginPathParams)
	// Mobile login using mobile number and password
	// (POST /api/v2/auth/mobile-login)
	AuthMobileLoginPath(c *gin.Context, params AuthMobileLoginPathParams)
	// Display folder file
	// (GET /api/v2/folder-file-display/folder-file-original/{folderFileId})
	FolderFileDisplayOriginalPath(c *gin.Context, folderFileId int64, params FolderFileDisplayOriginalPathParams)
	// Display folder file
	// (GET /api/v2/folder-file-display/folder-file-thumbnail/{folderFileId})
	FolderFileDisplayThumbnailPath(c *gin.Context, folderFileId int64, params FolderFileDisplayThumbnailPathParams)
	// Display folder file
	// (GET /api/v2/folder-file-display/folder-file/{folderFileId})
	FolderFileDisplayPath(c *gin.Context, folderFileId int64, params FolderFileDisplayPathParams)
	// Folder file chunk upload
	// (POST /api/v2/folder-files/chunk-upload-folder-file-init-upload-id)
	FolderFileGetChunkUploadIdPath(c *gin.Context, params FolderFileGetChunkUploadIdPathParams)
	// Folder file chunk upload
	// (POST /api/v2/folder-files/chunk-upload-folder-file/{folderId})
	FolderFileChunkUploadPath(c *gin.Context, folderId int64, params FolderFileChunkUploadPathParams)
	// Delete folder files based on ids
	// (POST /api/v2/folder-files/delete-files/{folderId})
	FolderFileDeleteFolderFilesPath(c *gin.Context, folderId int64, params FolderFileDeleteFolderFilesPathParams)
	// Get folder files after date time
	// (POST /api/v2/folder-files/get-folder-files-after-micro-timestamp/{folderId}/{pivotDate}/{microTimestamp})
	FolderFileGetFolderFilesAfterMicroTimestampShotAt(c *gin.Context, folderId int64, pivotDate string, microTimestamp int64, params FolderFileGetFolderFilesAfterMicroTimestampShotAtParams)
	// Get folder files before date time
	// (POST /api/v2/folder-files/get-folder-files-before-micro-timestamp/{folderId}/{pivotDate}/{microTimestamp})
	FolderFileGetFolderFilesBeforeMicroTimestampShotAt(c *gin.Context, folderId int64, pivotDate string, microTimestamp int64, params FolderFileGetFolderFilesBeforeMicroTimestampShotAtParams)
	// Update multiple folder files
	// (POST /api/v2/folder-files/update-multiple-folder-files)
	FolderFileUpdateMultipleFolderFilesPath(c *gin.Context, params FolderFileUpdateMultipleFolderFilesPathParams)
	// Update one single folder file
	// (POST /api/v2/folder-files/update-single-folder-file)
	FolderFileUpdateSingleFolderFilePath(c *gin.Context, params FolderFileUpdateSingleFolderFilePathParams)
	// Delete user's folder
	// (POST /api/v2/folder/delete-folder/{folderId})
	FolderFileDeleteFolderPath(c *gin.Context, folderId int64, params FolderFileDeleteFolderPathParams)
	// Save folder
	// (POST /api/v2/folder/save-folder/{folderId})
	FolderFileSaveFolderPath(c *gin.Context, folderId int64, params FolderFileSaveFolderPathParams)
	// Delete user's locker note
	// (POST /api/v2/locker-notes/delete-note/{noteId})
	LockerNoteDeletePath(c *gin.Context, noteId int64, params LockerNoteDeletePathParams)
	// List user's locker notes
	// (POST /api/v2/locker-notes/list-notes)
	LockerNoteListPath(c *gin.Context, params LockerNoteListPathParams)
	// Save user's locker note
	// (POST /api/v2/locker-notes/save-note/{noteId})
	LockerNoteSavePath(c *gin.Context, noteId int64, params LockerNoteSavePathParams)
	// Update user's profile
	// (POST /api/v2/user/update-profile)
	UserUpdateProfilePath(c *gin.Context, params UserUpdateProfilePathParams)
	// Base64 encoded chunk upload
	// (POST /api/v2/util/base64-chunked-upload-file)
	UtilBase64ChunkUploadPath(c *gin.Context, params UtilBase64ChunkUploadPathParams)
	// Check for update
	// (GET /api/v2/util/check-for-mobile-update/{clientOs}/{clientVersion})
	UtilCheckForUpdatePath(c *gin.Context, clientOs string, clientVersion string, params UtilCheckForUpdatePathParams)
	// Get system config
	// (POST /api/v2/util/config/{configKey})
	UtilConfigPath(c *gin.Context, configKey string, params UtilConfigPathParams)
	// Ping for health
	// (GET /api/v2/util/ping)
	UtilPingPath(c *gin.Context, params UtilPingPathParams)
	// Display user avatar
	// (GET /api/v2/util/user-avatar/{userId})
	UtilDisplayUserAvatarPath(c *gin.Context, userId int64, params UtilDisplayUserAvatarPathParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// AdminAddUserPath operation middleware
func (siw *ServerInterfaceWrapper) AdminAddUserPath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminAddUserPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AdminAddUserPath(c, params)
}

// AdminDeleteUserPath operation middleware
func (siw *ServerInterfaceWrapper) AdminDeleteUserPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid string

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", c.Param("uuid"), &uuid, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter uuid: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminDeleteUserPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AdminDeleteUserPath(c, uuid, params)
}

// AdminListUsersPath operation middleware
func (siw *ServerInterfaceWrapper) AdminListUsersPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "afterId" -------------
	var afterId int64

	err = runtime.BindStyledParameterWithOptions("simple", "afterId", c.Param("afterId"), &afterId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter afterId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminListUsersPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AdminListUsersPath(c, afterId, params)
}

// AdminSaveUserPath operation middleware
func (siw *ServerInterfaceWrapper) AdminSaveUserPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId int64

	err = runtime.BindStyledParameterWithOptions("simple", "userId", c.Param("userId"), &userId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter userId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminSaveUserPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AdminSaveUserPath(c, userId, params)
}

// AuthAccessTokenLoginPath operation middleware
func (siw *ServerInterfaceWrapper) AuthAccessTokenLoginPath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthAccessTokenLoginPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AuthAccessTokenLoginPath(c, params)
}

// AuthMobileLoginPath operation middleware
func (siw *ServerInterfaceWrapper) AuthMobileLoginPath(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthMobileLoginPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AuthMobileLoginPath(c, params)
}

// FolderFileDisplayOriginalPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileDisplayOriginalPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderFileId" -------------
	var folderFileId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderFileId", c.Param("folderFileId"), &folderFileId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderFileId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileDisplayOriginalPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileDisplayOriginalPath(c, folderFileId, params)
}

// FolderFileDisplayThumbnailPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileDisplayThumbnailPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderFileId" -------------
	var folderFileId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderFileId", c.Param("folderFileId"), &folderFileId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderFileId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileDisplayThumbnailPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileDisplayThumbnailPath(c, folderFileId, params)
}

// FolderFileDisplayPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileDisplayPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderFileId" -------------
	var folderFileId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderFileId", c.Param("folderFileId"), &folderFileId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderFileId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileDisplayPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileDisplayPath(c, folderFileId, params)
}

// FolderFileGetChunkUploadIdPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileGetChunkUploadIdPath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileGetChunkUploadIdPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileGetChunkUploadIdPath(c, params)
}

// FolderFileChunkUploadPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileChunkUploadPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderId" -------------
	var folderId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderId", c.Param("folderId"), &folderId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileChunkUploadPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	// ------------- Required header parameter "HasMore" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("HasMore")]; found {
		var HasMore string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for HasMore, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "HasMore", valueList[0], &HasMore, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter HasMore: %w", err), http.StatusBadRequest)
			return
		}

		params.HasMore = HasMore

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter HasMore is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "Filename" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Filename")]; found {
		var Filename string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Filename, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Filename", valueList[0], &Filename, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Filename: %w", err), http.StatusBadRequest)
			return
		}

		params.Filename = Filename

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Filename is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "ChunkIndex" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("ChunkIndex")]; found {
		var ChunkIndex string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for ChunkIndex, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "ChunkIndex", valueList[0], &ChunkIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ChunkIndex: %w", err), http.StatusBadRequest)
			return
		}

		params.ChunkIndex = ChunkIndex

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter ChunkIndex is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "UploadId" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("UploadId")]; found {
		var UploadId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for UploadId, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "UploadId", valueList[0], &UploadId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter UploadId: %w", err), http.StatusBadRequest)
			return
		}

		params.UploadId = UploadId

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter UploadId is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileChunkUploadPath(c, folderId, params)
}

// FolderFileDeleteFolderFilesPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileDeleteFolderFilesPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderId" -------------
	var folderId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderId", c.Param("folderId"), &folderId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileDeleteFolderFilesPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileDeleteFolderFilesPath(c, folderId, params)
}

// FolderFileGetFolderFilesAfterMicroTimestampShotAt operation middleware
func (siw *ServerInterfaceWrapper) FolderFileGetFolderFilesAfterMicroTimestampShotAt(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderId" -------------
	var folderId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderId", c.Param("folderId"), &folderId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "pivotDate" -------------
	var pivotDate string

	err = runtime.BindStyledParameterWithOptions("simple", "pivotDate", c.Param("pivotDate"), &pivotDate, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pivotDate: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "microTimestamp" -------------
	var microTimestamp int64

	err = runtime.BindStyledParameterWithOptions("simple", "microTimestamp", c.Param("microTimestamp"), &microTimestamp, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter microTimestamp: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileGetFolderFilesAfterMicroTimestampShotAtParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileGetFolderFilesAfterMicroTimestampShotAt(c, folderId, pivotDate, microTimestamp, params)
}

// FolderFileGetFolderFilesBeforeMicroTimestampShotAt operation middleware
func (siw *ServerInterfaceWrapper) FolderFileGetFolderFilesBeforeMicroTimestampShotAt(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderId" -------------
	var folderId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderId", c.Param("folderId"), &folderId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "pivotDate" -------------
	var pivotDate string

	err = runtime.BindStyledParameterWithOptions("simple", "pivotDate", c.Param("pivotDate"), &pivotDate, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pivotDate: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "microTimestamp" -------------
	var microTimestamp int64

	err = runtime.BindStyledParameterWithOptions("simple", "microTimestamp", c.Param("microTimestamp"), &microTimestamp, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter microTimestamp: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileGetFolderFilesBeforeMicroTimestampShotAtParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileGetFolderFilesBeforeMicroTimestampShotAt(c, folderId, pivotDate, microTimestamp, params)
}

// FolderFileUpdateMultipleFolderFilesPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileUpdateMultipleFolderFilesPath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileUpdateMultipleFolderFilesPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileUpdateMultipleFolderFilesPath(c, params)
}

// FolderFileUpdateSingleFolderFilePath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileUpdateSingleFolderFilePath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileUpdateSingleFolderFilePathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileUpdateSingleFolderFilePath(c, params)
}

// FolderFileDeleteFolderPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileDeleteFolderPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderId" -------------
	var folderId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderId", c.Param("folderId"), &folderId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileDeleteFolderPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileDeleteFolderPath(c, folderId, params)
}

// FolderFileSaveFolderPath operation middleware
func (siw *ServerInterfaceWrapper) FolderFileSaveFolderPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "folderId" -------------
	var folderId int64

	err = runtime.BindStyledParameterWithOptions("simple", "folderId", c.Param("folderId"), &folderId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter folderId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FolderFileSaveFolderPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FolderFileSaveFolderPath(c, folderId, params)
}

// LockerNoteDeletePath operation middleware
func (siw *ServerInterfaceWrapper) LockerNoteDeletePath(c *gin.Context) {

	var err error

	// ------------- Path parameter "noteId" -------------
	var noteId int64

	err = runtime.BindStyledParameterWithOptions("simple", "noteId", c.Param("noteId"), &noteId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter noteId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params LockerNoteDeletePathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.LockerNoteDeletePath(c, noteId, params)
}

// LockerNoteListPath operation middleware
func (siw *ServerInterfaceWrapper) LockerNoteListPath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params LockerNoteListPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.LockerNoteListPath(c, params)
}

// LockerNoteSavePath operation middleware
func (siw *ServerInterfaceWrapper) LockerNoteSavePath(c *gin.Context) {

	var err error

	// ------------- Path parameter "noteId" -------------
	var noteId int64

	err = runtime.BindStyledParameterWithOptions("simple", "noteId", c.Param("noteId"), &noteId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter noteId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params LockerNoteSavePathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.LockerNoteSavePath(c, noteId, params)
}

// UserUpdateProfilePath operation middleware
func (siw *ServerInterfaceWrapper) UserUpdateProfilePath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UserUpdateProfilePathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UserUpdateProfilePath(c, params)
}

// UtilBase64ChunkUploadPath operation middleware
func (siw *ServerInterfaceWrapper) UtilBase64ChunkUploadPath(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UtilBase64ChunkUploadPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UtilBase64ChunkUploadPath(c, params)
}

// UtilCheckForUpdatePath operation middleware
func (siw *ServerInterfaceWrapper) UtilCheckForUpdatePath(c *gin.Context) {

	var err error

	// ------------- Path parameter "clientOs" -------------
	var clientOs string

	err = runtime.BindStyledParameterWithOptions("simple", "clientOs", c.Param("clientOs"), &clientOs, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter clientOs: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "clientVersion" -------------
	var clientVersion string

	err = runtime.BindStyledParameterWithOptions("simple", "clientVersion", c.Param("clientVersion"), &clientVersion, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter clientVersion: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UtilCheckForUpdatePathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UtilCheckForUpdatePath(c, clientOs, clientVersion, params)
}

// UtilConfigPath operation middleware
func (siw *ServerInterfaceWrapper) UtilConfigPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "configKey" -------------
	var configKey string

	err = runtime.BindStyledParameterWithOptions("simple", "configKey", c.Param("configKey"), &configKey, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter configKey: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UtilConfigPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UtilConfigPath(c, configKey, params)
}

// UtilPingPath operation middleware
func (siw *ServerInterfaceWrapper) UtilPingPath(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UtilPingPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UtilPingPath(c, params)
}

// UtilDisplayUserAvatarPath operation middleware
func (siw *ServerInterfaceWrapper) UtilDisplayUserAvatarPath(c *gin.Context) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId int64

	err = runtime.BindStyledParameterWithOptions("simple", "userId", c.Param("userId"), &userId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter userId: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UtilDisplayUserAvatarPathParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Language")]; found {
		var AcceptLanguage string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Language, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Language", valueList[0], &AcceptLanguage, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Language: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptLanguage = &AcceptLanguage

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UtilDisplayUserAvatarPath(c, userId, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/api/v2/admin/add-user", wrapper.AdminAddUserPath)
	router.POST(options.BaseURL+"/api/v2/admin/delete-user/:uuid", wrapper.AdminDeleteUserPath)
	router.POST(options.BaseURL+"/api/v2/admin/list-all-users/:afterId", wrapper.AdminListUsersPath)
	router.POST(options.BaseURL+"/api/v2/admin/update-user/:userId", wrapper.AdminSaveUserPath)
	router.POST(options.BaseURL+"/api/v2/auth/access-token-login", wrapper.AuthAccessTokenLoginPath)
	router.POST(options.BaseURL+"/api/v2/auth/mobile-login", wrapper.AuthMobileLoginPath)
	router.GET(options.BaseURL+"/api/v2/folder-file-display/folder-file-original/:folderFileId", wrapper.FolderFileDisplayOriginalPath)
	router.GET(options.BaseURL+"/api/v2/folder-file-display/folder-file-thumbnail/:folderFileId", wrapper.FolderFileDisplayThumbnailPath)
	router.GET(options.BaseURL+"/api/v2/folder-file-display/folder-file/:folderFileId", wrapper.FolderFileDisplayPath)
	router.POST(options.BaseURL+"/api/v2/folder-files/chunk-upload-folder-file-init-upload-id", wrapper.FolderFileGetChunkUploadIdPath)
	router.POST(options.BaseURL+"/api/v2/folder-files/chunk-upload-folder-file/:folderId", wrapper.FolderFileChunkUploadPath)
	router.POST(options.BaseURL+"/api/v2/folder-files/delete-files/:folderId", wrapper.FolderFileDeleteFolderFilesPath)
	router.POST(options.BaseURL+"/api/v2/folder-files/get-folder-files-after-micro-timestamp/:folderId/:pivotDate/:microTimestamp", wrapper.FolderFileGetFolderFilesAfterMicroTimestampShotAt)
	router.POST(options.BaseURL+"/api/v2/folder-files/get-folder-files-before-micro-timestamp/:folderId/:pivotDate/:microTimestamp", wrapper.FolderFileGetFolderFilesBeforeMicroTimestampShotAt)
	router.POST(options.BaseURL+"/api/v2/folder-files/update-multiple-folder-files", wrapper.FolderFileUpdateMultipleFolderFilesPath)
	router.POST(options.BaseURL+"/api/v2/folder-files/update-single-folder-file", wrapper.FolderFileUpdateSingleFolderFilePath)
	router.POST(options.BaseURL+"/api/v2/folder/delete-folder/:folderId", wrapper.FolderFileDeleteFolderPath)
	router.POST(options.BaseURL+"/api/v2/folder/save-folder/:folderId", wrapper.FolderFileSaveFolderPath)
	router.POST(options.BaseURL+"/api/v2/locker-notes/delete-note/:noteId", wrapper.LockerNoteDeletePath)
	router.POST(options.BaseURL+"/api/v2/locker-notes/list-notes", wrapper.LockerNoteListPath)
	router.POST(options.BaseURL+"/api/v2/locker-notes/save-note/:noteId", wrapper.LockerNoteSavePath)
	router.POST(options.BaseURL+"/api/v2/user/update-profile", wrapper.UserUpdateProfilePath)
	router.POST(options.BaseURL+"/api/v2/util/base64-chunked-upload-file", wrapper.UtilBase64ChunkUploadPath)
	router.GET(options.BaseURL+"/api/v2/util/check-for-mobile-update/:clientOs/:clientVersion", wrapper.UtilCheckForUpdatePath)
	router.POST(options.BaseURL+"/api/v2/util/config/:configKey", wrapper.UtilConfigPath)
	router.GET(options.BaseURL+"/api/v2/util/ping", wrapper.UtilPingPath)
	router.GET(options.BaseURL+"/api/v2/util/user-avatar/:userId", wrapper.UtilDisplayUserAvatarPath)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
